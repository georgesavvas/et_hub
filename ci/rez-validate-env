#!/usr/bin/env python
from __future__ import print_function
import re
import sys
import argparse
from copy import copy
from shutil import rmtree
from subprocess import check_output
from os.path import dirname, expanduser, join

sys.path.append(dirname(__file__))

import ci_utils as ci  # NOQA

coverage_re = re.compile('.*?(\d+) *?(\d+) *?\d+%')


def main():
    parser = argparse.ArgumentParser(description='Build and Test Software')
    parser.add_argument('--build', help='Build the software.', action='store_true')
    parser.add_argument('--merges', help='Include merges.', action='store_true')
    parser.add_argument(
        '--partial',
        help='Test packages that have tests and need to be built',
        action='store_true',
    )
    parser.add_argument(
        '--full', help='Test all software that have tests.', action='store_true',
    )

    args = parser.parse_args()

    cmd = (
        "git diff-tree --no-commit-id " "--name-only -r `git log --format=\"%H\" -n 1`"
    )
    build_files = ci.process_files(cmd)

    if args.merges:
        cmd = (
            "git log -m -1 --name-only "
            "--pretty=\"format:\" `git log --format=%H -n 1`"
        )
        merged_files = ci.process_files(cmd)
    else:
        merged_files = []

    build_packages = ci.find_internal_packages(build_files)
    merged_packages = ci.find_internal_packages(merged_files)

    if args.full:
        build_packages = list(set(build_packages + merged_packages))
    else:
        build_packages = list(set(build_packages + merged_packages))

    if args.build:
        print("== about to build the following packages ==")
        for s in build_packages:
            print(s)
        print("== END ==")
        done, packages_build = ci.process_until_empty(
            "rez build -i", copy(build_packages)
        )

        if not done:
            print("there might be a issues and some packages can't be released")
            remove_builds(packages_build)
            return 1

    if args.full or args.partial:
        to_test_packages = list(set(build_packages + merged_packages))
    else:
        to_test_packages = []

    to_test_package_versions = []
    for package in to_test_packages:
        with open(join(package, 'VERSION')) as f:
            to_test_package_versions.append(package + '-' + f.read().strip())

    print("== validate no rez conflict with all latest packages ==")
    any_failure = test_env(to_test_package_versions)
    remove_builds(packages_build)
    print("== END ==")

    return any_failure


def test_env(test_package_versions):
    cmd = "rez env " + " ".join(test_package_versions)
    print(cmd)
    output = check_output(cmd, shell=True, universal_newlines=True,)
    failed_context = "The context failed to resolve" in output
    if ci.NOTFOUND.findall(output) or failed_context:
        print(output)
        return 1

    return 0


def remove_builds(test_packages):
    local_path = check_output(
        "rez config local_packages_path", shell=True, universal_newlines=True,
    )
    local_path = local_path.strip()
    for path in test_packages:
        try:
            rmtree(expanduser('{0}/{1}'.format(local_path, path)))
        except:
            pass


if __name__ == '__main__':
    sys.exit(main())
